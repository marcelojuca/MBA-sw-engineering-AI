# Prompt Chaining Result

## SCHEMA (Generated by GPT-3.5-turbo)
```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid"
    },
    "name": {
      "type": "string"
    },
    "description": {
      "type": "string"
    },
    "price": {
      "type": "number",
      "minimum": 0
    },
    "stock": {
      "type": "integer",
      "minimum": 0
    }
  },
  "required": ["name"]
}
```

## ROUTES & HANDLERS (Go) (Generated by GPT-5-mini)
Below is a concise, production-oriented design of REST routes and idiomatic Go handlers for CRUD based on your JSON schema (a "product" resource). It includes:

- route design
- request/response shape
- validation
- repository interface + in-memory implementation (thread-safe)
- handlers with proper HTTP status codes, JSON encoding, error handling, and basic pagination for listing

All code is kept compact and ready to drop into a service.

1) Routes
- POST   /products          -> CreateProduct
- GET    /products          -> ListProducts (query: ?limit=&offset=)
- GET    /products/{id}     -> GetProduct
- PUT    /products/{id}     -> UpdateProduct
- DELETE /products/{id}     -> DeleteProduct

2) Code

models.go
```go
package main

import (
	"errors"
	"fmt"

	"github.com/google/uuid"
)

var ErrNotFound = errors.New("not found")

type Product struct {
	ID          string  `json:"id,omitempty"`
	Name        string  `json:"name"`
	Description string  `json:"description,omitempty"`
	Price       float64 `json:"price,omitempty"`
	Stock       int     `json:"stock,omitempty"`
}

// Validate validates business rules defined by the JSON schema.
// acceptID controls whether an ID must be present/valid (used for some flows).
func (p *Product) Validate(acceptID bool) error {
	if p.Name == "" {
		return fmt.Errorf("name is required")
	}
	if p.Price < 0 {
		return fmt.Errorf("price must be >= 0")
	}
	if p.Stock < 0 {
		return fmt.Errorf("stock must be >= 0")
	}
	if acceptID && p.ID != "" {
		if _, err := uuid.Parse(p.ID); err != nil {
			return fmt.Errorf("id must be a valid uuid")
		}
	}
	return nil
}
```

store.go
```go
package main

import (
	"context"
	"sync"
)

// Store is an abstract persistence layer.
type Store interface {
	Create(ctx context.Context, p *Product) error
	Get(ctx context.Context, id string) (*Product, error)
	List(ctx context.Context, limit, offset int) ([]*Product, error)
	Update(ctx context.Context, p *Product) error
	Delete(ctx context.Context, id string) error
}

// InMemoryStore is a simple thread-safe in-memory store for examples / tests.
type InMemoryStore struct {
	mu   sync.RWMutex
	data map[string]*Product
}

func NewInMemoryStore() *InMemoryStore {
	return &InMemoryStore{
		data: make(map[string]*Product),
	}
}

func (s *InMemoryStore) Create(ctx context.Context, p *Product) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.data[p.ID] = clone(p)
	return nil
}

func (s *InMemoryStore) Get(ctx context.Context, id string) (*Product, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if p, ok := s.data[id]; ok {
		return clone(p), nil
	}
	return nil, ErrNotFound
}

func (s *InMemoryStore) List(ctx context.Context, limit, offset int) ([]*Product, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	res := make([]*Product, 0, len(s.data))
	for _, p := range s.data {
		res = append(res, clone(p))
	}
	// deterministic ordering not guaranteed in map; for simplicity we skip ordering.
	// apply offset/limit
	if offset >= len(res) {
		return []*Product{}, nil
	}
	end := offset + limit
	if end > len(res) {
		end = len(res)
	}
	return res[offset:end], nil
}

func (s *InMemoryStore) Update(ctx context.Context, p *Product) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, ok := s.data[p.ID]; !ok {
		return ErrNotFound
	}
	s.data[p.ID] = clone(p)
	return nil
}

func (s *InMemoryStore) Delete(ctx context.Context, id string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, ok := s.data[id]; !ok {
		return ErrNotFound
	}
	delete(s.data, id)
	return nil
}

func clone(p *Product) *Product {
	if p == nil {
		return nil
	}
	cp := *p
	return &cp
}
```

handlers.go
```go
package main

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"log"
	"net/http"
	"strconv"
	"strings"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
)

type API struct {
	store Store
}

func NewAPI(s Store) *API { return &API{store: s} }

// helper: write JSON response
func writeJSON(w http.ResponseWriter, status int, v interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(v)
}

// helper: error JSON
func writeError(w http.ResponseWriter, status int, msg string) {
	writeJSON(w, status, map[string]string{"error": msg})
}

// helper: strict decode
func decodeJSON(r *http.Request, dst interface{}) error {
	r.Body = http.MaxBytesReader(nil, r.Body, 1<<20) // 1MB
	dec := json.NewDecoder(r.Body)
	dec.DisallowUnknownFields()
	if err := dec.Decode(dst); err != nil {
		if errors.Is(err, io.EOF) {
			return errors.New("empty body")
		}
		return err
	}
	// ensure no trailing data
	if dec.More() {
		return errors.New("body must contain a single JSON object")
	}
	return nil
}

// CreateProduct POST /products
func (a *API) CreateProduct(w http.ResponseWriter, r *http.Request) {
	var in Product
	if err := decodeJSON(r, &in); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}
	// id is generated by server
	in.ID = uuid.NewString()
	if err := in.Validate(false); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}
	if err := a.store.Create(r.Context(), &in); err != nil {
		log.Printf("store create error: %v", err)
		writeError(w, http.StatusInternalServerError, "internal")
		return
	}
	w.Header().Set("Location", "/products/"+in.ID)
	writeJSON(w, http.StatusCreated, in)
}

// GetProduct GET /products/{id}
func (a *API) GetProduct(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if strings.TrimSpace(id) == "" {
		writeError(w, http.StatusBadRequest, "id is required")
		return
	}
	p, err := a.store.Get(r.Context(), id)
	if err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		log.Printf("store get error: %v", err)
		writeError(w, http.StatusInternalServerError, "internal")
		return
	}
	writeJSON(w, http.StatusOK, p)
}

// ListProducts GET /products?limit=&offset=
func (a *API) ListProducts(w http.ResponseWriter, r *http.Request) {
	limit := 25
	offset := 0
	if v := r.URL.Query().Get("limit"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n > 0 {
			if n > 100 {
				n = 100
			}
			limit = n
		}
	}
	if v := r.URL.Query().Get("offset"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n >= 0 {
			offset = n
		}
	}
	list, err := a.store.List(r.Context(), limit, offset)
	if err != nil {
		log.Printf("store list error: %v", err)
		writeError(w, http.StatusInternalServerError, "internal")
		return
	}
	writeJSON(w, http.StatusOK, list)
}

// UpdateProduct PUT /products/{id}
func (a *API) UpdateProduct(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if _, err := uuid.Parse(id); err != nil {
		writeError(w, http.StatusBadRequest, "invalid id")
		return
	}
	var in Product
	if err := decodeJSON(r, &in); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}
	// force path id to resource
	in.ID = id
	if err := in.Validate(true); err != nil {
		writeError(w, http.StatusBadRequest, err.Error())
		return
	}
	if err := a.store.Update(r.Context(), &in); err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		log.Printf("store update error: %v", err)
		writeError(w, http.StatusInternalServerError, "internal")
		return
	}
	writeJSON(w, http.StatusOK, in)
}

// DeleteProduct DELETE /products/{id}
func (a *API) DeleteProduct(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if _, err := uuid.Parse(id); err != nil {
		writeError(w, http.StatusBadRequest, "invalid id")
		return
	}
	if err := a.store.Delete(r.Context(), id); err != nil {
		if err == ErrNotFound {
			writeError(w, http.StatusNotFound, "product not found")
			return
		}
		log.Printf("store delete error: %v", err)
		writeError(w, http.StatusInternalServerError, "internal")
		return
	}
	w.WriteHeader(http.StatusNoContent)
}
```

main.go (router wiring)
```go
package main

import (
	"log"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func main() {
	store := NewInMemoryStore()
	api := NewAPI(store)

	r := chi.NewRouter()
	r.Post("/products", api.CreateProduct)
	r.Get("/products", api.ListProducts)
	r.Get("/products/{id}", api.GetProduct)
	r.Put("/products/{id}", api.UpdateProduct)
	r.Delete("/products/{id}", api.DeleteProduct)

	log.Println("listening :8080")
	if err := http.ListenAndServe(":8080", r); err != nil {
		log.Fatalf("server failed: %v", err)
	}
}
```

Notes & suggestions for production:
- Replace InMemoryStore with a real database implementation (SQL/NoSQL), and implement pagination & ordering in queries.
- Use structured logging (e.g., zerolog/logrus) and centralized error handling/middleware (timings, request IDs).
- Add authentication/authorization, rate-limiting, and OpenAPI docs.
- Consider PATCH for partial updates and validation libraries (go-playground/validator) for complex rules.
- Add tests for handlers and store implementations.

This should give you a solid, idiomatic starting point for CRUD for your schema.

## COMMIT (Generated by GPT-4o-mini)
```
feat(api): implement CRUD operations for product resource with validation and pagination
```

---
**Pipeline Models:**
- Step 1: GPT-3.5-turbo
- Step 2: GPT-5-mini
- Step 3: GPT-4o-mini  

